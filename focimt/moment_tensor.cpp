//-----------------------------------------------------------------------------
// Source: moment_tensor.cpp
// Module: focimt
// Main routine.
//
// Copyright (c) 2013-2015, Grzegorz Kwiatek.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//-----------------------------------------------------------------------------
#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <iostream>
#include <fstream>
#include <trilib/string.h>
#include <trilib/georoutines.h>
#include <tricairo/tricairo_meca.h>
//-----------------------------------------------------------------------------
#include "getopts.h"
#include "faultsolution.h"
#include "inputdata.h"
#include "usmtcore.h"
//-----------------------------------------------------------------------------

#define TT1D_RAYTRACE_MAXLAY (20)
#define TT1D_MAXT (100000.0)
void CalcTravelTime1D(double sta_elev, double depth, double delta,
    std::vector<double> Top, std::vector<double> Velocity, double &traveltime,
    double &takeoff, bool &directphase, double &aoi, int &kk, double &ray_dist);
void refract(const int nl, const double v[], const double vsq[],
    const double thk[], const int jl, const double tkj, const double delta,
    int &kk, double &tref, double &xovmax, double &ray_refract);
void tiddid(const int &jl, const int &nl, const double v[], const double vsq[],
    const double thk[], double tid[], double did[], double rid[]);
void ttime(const double &delta, const double &depth, const int &nl,
    const double v[], const double top[], double &t, double &ain,
    bool &directphase, double &aoi, int &kk, double &ray_dist);
void vmodel(const int& nl, const double v[], const double top[],
    const double &depth, double vsq[], double thk[], int &jl, double &tkj);
void direct1(const int &nl, const double v[], const double vsq[],
    const double thk[], const int& jl, const double& tkj, const double& delta,
    const double& depth, double& tdir, double& u, double& x,
    double &ray_direct);

using namespace std;

#define squared(x) (pow(x,2.0))

// Default values.
bool DrawStations = true;
bool DrawAxes = true;
bool DrawCross = true;
bool DrawDC = true;
bool WulffProjection = false;
bool LowerHemisphere = true;

//-----------------------------------------------------------------------------
class FaultSolutions {
  public:
    char Type;
    int Channel;
    Taquart::FaultSolution FullSolution;
    Taquart::FaultSolution TraceNullSolution;
    Taquart::FaultSolution DoubleCoupleSolution;
};

//-----------------------------------------------------------------------------
void GenerateBallCairo(Taquart::TriCairo_Meca &Meca,
    std::vector<FaultSolutions> &FSList, Taquart::SMTInputData &InputData,
    Taquart::String Type);

//-----------------------------------------------------------------------------
bool Dispatch(Taquart::String &Input, Taquart::String &Chunk,
    Taquart::String delimiter) {
  if (Input.Pos(delimiter) == 0)
    return false;
  else {
    Chunk = Input.SubString(1, Input.Pos(delimiter) - 1);
    Input = Input.SubString(Input.Pos(delimiter) + 1, 10000);
    return true;
  }
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
int main(int argc, char* argv[]) {
  try {
    Taquart::String FilenameIn;
    Taquart::String FilenameOut;
    Taquart::String FilenameVelocity;
    unsigned int N = 14;

    Options listOpts;
    int switchInt;
    listOpts.addOption("i", "input", "Full path to the input file", true);
    listOpts.addOption("o", "output", "Output file name (without extension)",
        true);
    listOpts.addOption("s", "solution",
        "Output solution type.                                \n\n"
            "    Arguments: [F][T][D] for the full, trace-null and double-couple solution.  \n"
            "    Default option is '-s D'. Combine options to get multiple solutions, e.g.  \n"
            "    '-s DFT' produces all three solutions at once.                             \n",
        true);
    listOpts.addOption("t", "type",
        "Output file type.                                    \n\n"
            "    Arguments: [NONE|PNG|SVG|PS|PDF] for different file types (only one can) be\n"
            "    specified as an output. The default value is '-t PNG'                      \n",
        true);
    listOpts.addOption("n", "norm",
        "Norm type.               \n\n"
            "    Arguments: [L1|L2] for L1 and L2 norm, respectively. The default option is \n"
            "    is '-n L2' (faster). When Jacknife method is used the option is ignored and\n"
            "    L2 norm is used.                                                           \n",
        true);
    listOpts.addOption("p", "projection",
        "Projection type.                                     \n\n"
            "    Arguments: [W|S][U|L]: Choose either (W)ulff projection or (S)chmidt       \n"
            "    projection. Then select (U)pper hemisphere or (L)ower hemispere projection \n"
            "    The default option is '-p SL'.                                             \n",
        true);
    listOpts.addOption("b", "ball",
        "The details of the beach ball picture                \n\n"
            "    Arguments: [S][A][C][D]: Plot (S)tations, (A)xes, (C)enter cross, best     \n"
            "    (D)ouble-couple lines. The default option is '-b SACD' (all features are   \n"
            "    displayed                                                                  \n",
        true);
    listOpts.addOption("d", "dump",
        "Output data format and order.                        \n\n"
            "    Arguments: [M][C][F][D][A][W][Q][T][U].                                    \n"
            "    [M]: Moment tensor components in Aki's convention: M11,M12,M13,M22,M23,M33.\n"
            "         The moment tensor components are in [Nm]                              \n"
            "    [C]: Moment tensor components in CMT conventions: M33,M11,M22,M13,-M23,-M12\n"
            "         The moment tensor components are in [Nm]                              \n"
            "    [F]: Fault plane solutions in format: STRIKEA/DIPA/RAKEA/STRIKEB/DIPB/RAKEB\n"
            "         (all values in degrees)                                               \n"
            "    [D]: Decomposition of the moment tensor into Isotropic, Compensated linear \n"
            "         vector dipole and double couple in format: ISO/CLVD/DBCP. The numbers \n"
            "         are provided in %.                                                    \n"
            "    [A]: P/T/B Axes orientations in format:                                    \n"
            "         PTREND/PPLUNGE/TTREND/TPLUNGE/BTREND/BPLUNGE                          \n"
            "    [W]: Seismic moment, total seismic moment, maximum error of the seismic    \n"
            "         moment tensor estiamte and the moment magnitude calculated using      \n"
            "         using Hanks&Kanamori formula. The first three values are in [Nm]      \n"
            "    [Q]: Quality index                                                         \n"
            "    [T]: Fault Type (strike slip/normal/inverse)                               \n"
            "    [U]: Vector of synthetic moments calculated (the number of exported numbers\n"
            "         correspond to the number of amplitudes in the input file (specified   \n"
            "         using '-l' option.                                                    \n"
            "    [E]: RMS Error calculated from theoretical and measured ground             \n"
            "         displacements.                                                        \n"
            "                                                                               \n"
            "    NOTE:                                                                      \n"
            "    The order of arguments determine to order of output. For example -d FAD    \n"
            "    exports firstly fault plane solutions, then P, T and B axes directions and \n"
            "    finally the moment tensor decomposition into ISO/CLVD/DBCP. The output file\n"
            "    will have the following structure:                                         \n"
            "    STRIKEA/DIPA/RAKEA/STRIKEB/DIPB/RAKEB/PTREND/PPLUNGE/TTREND/TPLUNGE/BTREND \n"
            "    /BPLUNGE/ISO/CLVD/DBCP                                                     \n",
        true);
    listOpts.addOption("l", "length",
        "Input data length.                                   \n\n"
            "    Argument: number of input lines, e.g. -l 12                                \n",
        true);
    listOpts.addOption("j", "jacknife", "Switches on/off Jacknife test.\n");
    listOpts.addOption("a", "amplitude",
        "Perform amplitude test.                              \n\n"
            "    Arguments: x[/y] where x is a floating-point positive number that describes\n"
            "    the level of noise applied to each amplitude: A+x*A*N(0,1)/3 where N is a  \n"
            "    normal distribution with mean 0 and std 1. The default value of x is 1     \n"
            "    (i.e.amplitude vary by a max. factor of ~2). Optional parameter /y is      \n"
            "    a number of samples (default value is 100).                                \n",
        true);
    listOpts.addOption("f", "fault",
        "Draw fault plane solution directly (and stations).   \n\n"
            "    Arguments: strike/dip/rake[:azimuth1/takeoff1][:azimuth2/takeoff2]...      \n"
            "                                                                               \n",
        true);
    listOpts.addOption("g", "faults",
        "Draw fault plane solution and bootstrap solutions.   \n\n"
            "    Arguments: strike/dip/rake[:s1/d1/r1][:s2/d2/r2]...      \n"
            "                                                                               \n",
        true);
    listOpts.addOption("m", "model",
        "Velocity model file (with extension)                 \n\n"
            "    Velocity model in hypo71 format. Forces different input file scheme.       \n",
        true);
    listOpts.addOption("v", "version", "Display version number");

    Taquart::String SolutionTypes = "D";
    Taquart::String NormType = "L2";
    Taquart::String Projection = "SL";
    Taquart::String BallContent = "SACD";
    Taquart::String DumpOrder = "";
    Taquart::String OutputFileType = "PNG";
    bool JacknifeTest = false;
    bool NoiseTest = false;
    bool DrawFaultOnly = false;
    bool DrawFaultsOnly = false;
    bool VelocityModel = false;
    double AmpFactor = 1.0f;
    unsigned int AmplitudeN = 100;
    Taquart::String Temp;
    Taquart::String FaultString;
    if (listOpts.parse(argc, argv))
      while ((switchInt = listOpts.cycle()) >= 0) {
        switch (switchInt) {
          case 0:
            FilenameIn =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim();
            break;
          case 1:
            FilenameOut =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim();
            break;
          case 2:
            SolutionTypes =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim();
            break;
          case 3:
            OutputFileType = Taquart::String(
                listOpts.getArgs(switchInt).c_str()).Trim().UpperCase();
            break;
          case 4:
            NormType =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim().UpperCase();
            break;
          case 5:
            Projection =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim().UpperCase();
            break;
          case 6:
            BallContent =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim().UpperCase();
            break;
          case 7:
            DumpOrder =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim().UpperCase();
            break;
          case 8:
            N =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim().ToInt();
            break;
          case 9:
            JacknifeTest = true;
            break;
          case 10:
            NoiseTest = true;
            Temp = Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim();
            if (Temp.Pos("/")) {
              AmpFactor = Temp.SubString(1, Temp.Pos("/") - 1).ToDouble();
              AmplitudeN = Temp.SubString(Temp.Pos("/") + 1, 1000).ToInt();
            }
            else {
              AmpFactor = Temp.ToDouble();
            }
            break;
          case 11:
            // Draw fault plane solutions only.
            DrawFaultOnly = true;
            FaultString =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim();
            break;
          case 12:
            // Draw fault plane solutions only.
            DrawFaultsOnly = true;
            FaultString =
                Taquart::String(listOpts.getArgs(switchInt).c_str()).Trim();
            break;
          case 13:
            // Use 1D velocity model from a file (forces different formatting of input file)
            VelocityModel = true;
            FilenameVelocity = Taquart::String(
                listOpts.getArgs(switchInt).c_str()).Trim();
            break;
          case 14:
            std::cout << "Rev. 3.1.0, 2015.01.29\n"
                "(c) 2011-2015 Grzegorz Kwiatek, GPL license applies.\n";
            break;
        }
      }

    if (FilenameIn.Length() == 0 && DrawFaultOnly == false
        && DrawFaultsOnly == false) {
      std::cout << "You must provide a valid filename." << std::endl;
    }

    if (FilenameOut.Length() == 0 && DrawFaultOnly == false
        && DrawFaultsOnly == false) {
      FilenameOut = Taquart::ExtractFileName(FilenameIn);
      if (FilenameOut.Pos("."))
        FilenameOut = FilenameOut.SubString(1, FilenameOut.Pos(".") - 1);
    }
    else if (FilenameOut.Length() == 0
        && (DrawFaultOnly == true || DrawFaultsOnly == true)) {
      FilenameOut = "default";
    }

    std::vector<double> Top;
    std::vector<double> Velocity;
    if (VelocityModel) {
      // Check if velocity model exists and read it.
      std::ifstream VelocityFile;
      int n;
      double v;
      VelocityFile.open(FilenameVelocity.c_str());
      VelocityFile >> n;
      for (int i = 0; i < n; i++) {
        VelocityFile >> v;
        Top.push_back(v);
      }
      for (int i = 0; i < n; i++) {
        VelocityFile >> v;
        Velocity.push_back(v);
      }
      VelocityFile.close();
    }

    // Draw fault only and return to dos...
    if (DrawFaultsOnly) {
      // Read strike, dip and rake.
      Taquart::String temp;
      double strike = 0, dip = 0, rake = 0;
      Dispatch(FaultString, temp, "/");
      strike = temp.ToDouble();
      Dispatch(FaultString, temp, "/");
      dip = temp.ToDouble();
      if (FaultString.Pos(":")) {
        rake = FaultString.SubString(1, FaultString.Pos(":") - 1).ToDouble();

        // Dispatch station data...
        Dispatch(FaultString, temp, ":"); // Cut rake part first, as it was already interpreted.

      }
      else {
        rake = FaultString.Trim().ToDouble();
        FaultString = "";
      }

      const double S = strike * DEG2RAD;
      const double D = dip * DEG2RAD;
      const double R = rake * DEG2RAD;

      // Transfer strike/dip/rake to tensor.
      double M11, M22, M33, M12, M13, M23;
      Taquart::StrikeDipRake2MT(S, D, R, M11, M22, M33, M12, M13, M23);

      std::vector<FaultSolutions> FSList;
      Taquart::SMTInputData InputData;

      FaultSolutions fs;
      Taquart::FaultSolution fu;
      Taquart::nodal_plane NP;

      fs.Type = 'N';
      fs.Channel = 0;

      fu.M[1][1] = M11;
      fu.M[1][2] = M12;
      fu.M[1][3] = M13;
      fu.M[2][1] = M12;
      fu.M[2][2] = M22;
      fu.M[2][3] = M23;
      fu.M[3][1] = M13;
      fu.M[3][2] = M23;
      fu.M[3][3] = M33;
      fu.FIA = strike;
      fu.DLA = dip;
      fu.RAKEA = rake;
      NP.str = strike;
      NP.dip = dip;
      NP.rake = rake;
      fu.FIB = Taquart::computed_strike1(NP);
      fu.DLB = Taquart::computed_dip1(NP);
      fu.RAKEB = Taquart::computed_rake1(NP);

      fs.FullSolution = fu;
      fs.TraceNullSolution = fu;
      fs.DoubleCoupleSolution = fu;

      FSList.push_back(fs);

      while (FaultString.Length()) {
        Dispatch(FaultString, temp, "/");
        strike = temp.ToDouble();
        Dispatch(FaultString, temp, "/");
        dip = temp.ToDouble();
        if (FaultString.Pos(":")) {
          rake = FaultString.SubString(1, FaultString.Pos(":") - 1).ToDouble();
          // Dispatch station data...
          Dispatch(FaultString, temp, ":"); // Cut rake part first, as it was already interpreted.
        }
        else {
          rake = FaultString.Trim().ToDouble();
          FaultString = "";
        }
        //
        double S = strike * DEG2RAD;
        double D = dip * DEG2RAD;
        double R = rake * DEG2RAD;

        double M11, M22, M33, M12, M13, M23;
        Taquart::StrikeDipRake2MT(S, D, R, M11, M22, M33, M12, M13, M23);

        fs.Type = 'J';
        fs.Channel = 0;
        fu.M[1][1] = M11;
        fu.M[1][2] = M12;
        fu.M[1][3] = M13;
        fu.M[2][1] = M12;
        fu.M[2][2] = M22;
        fu.M[2][3] = M23;
        fu.M[3][1] = M13;
        fu.M[3][2] = M23;
        fu.M[3][3] = M33;
        fu.FIA = strike;
        fu.DLA = dip;
        fu.RAKEA = rake;
        NP.str = strike;
        NP.dip = dip;
        NP.rake = rake;
        fu.FIB = Taquart::computed_strike1(NP);
        fu.DLB = Taquart::computed_dip1(NP);
        fu.RAKEB = Taquart::computed_rake1(NP);

        fs.FullSolution = fu;
        fs.TraceNullSolution = fu;
        fs.DoubleCoupleSolution = fu;

        FSList.push_back(fs);
      }

      Taquart::String OutName = FilenameOut + ".png";
      Taquart::TriCairo_Meca Meca(500, 500, Taquart::ctSurface);
      GenerateBallCairo(Meca, FSList, InputData, "dbcp");
      Meca.Save(OutName);

      return 0;
    }

    // Draw fault only and return to the system...
    if (DrawFaultOnly) {
      // Read strike, dip and rake.
      Taquart::String temp;
      double strike = 0, dip = 0, rake = 0;
      Dispatch(FaultString, temp, "/");
      strike = temp.ToDouble();
      Dispatch(FaultString, temp, "/");
      dip = temp.ToDouble();
      if (FaultString.Pos(":")) {
        rake = FaultString.SubString(1, FaultString.Pos(":") - 1).ToDouble();

        // Dispatch station data...
        Dispatch(FaultString, temp, ":"); // Cut rake part first, as it was already interpreted.

      }
      else {
        rake = FaultString.Trim().ToDouble();
        FaultString = "";
      }

      //std::cout << strike << " " << dip << " " << rake;

      double S = strike * DEG2RAD;
      double D = dip * DEG2RAD;
      double R = rake * DEG2RAD;

      // Transfer strike/dip/rake to tensor.
      double M11, M22, M33, M12, M13, M23;
      Taquart::StrikeDipRake2MT(S, D, R, M11, M22, M33, M12, M13, M23);

      std::vector<FaultSolutions> FSList;
      Taquart::SMTInputData InputData;

      FaultSolutions fs;
      Taquart::FaultSolution fu;
      Taquart::nodal_plane NP;

      fs.Type = 'N';
      fs.Channel = 0;

      fu.M[1][1] = M11;
      fu.M[1][2] = M12;
      fu.M[1][3] = M13;
      fu.M[2][1] = M12;
      fu.M[2][2] = M22;
      fu.M[2][3] = M23;
      fu.M[3][1] = M13;
      fu.M[3][2] = M23;
      fu.M[3][3] = M33;
      fu.FIA = strike;
      fu.DLA = dip;
      fu.RAKEA = rake;
      NP.str = strike;
      NP.dip = dip;
      NP.rake = rake;
      fu.FIB = Taquart::computed_strike1(NP);
      fu.DLB = Taquart::computed_dip1(NP);
      fu.RAKEB = Taquart::computed_rake1(NP);

      fs.FullSolution = fu;
      fs.TraceNullSolution = fu;
      fs.DoubleCoupleSolution = fu;

      FSList.push_back(fs);

      Taquart::String OutName = FilenameOut + ".png";
      Taquart::TriCairo_Meca Meca(500, 500, Taquart::ctSurface);
      GenerateBallCairo(Meca, FSList, InputData, "dbcp");
      Meca.Save(OutName);

      return 0;
    }

    // Prepare processing structure.
    Taquart::NormType InversionNormType =
        (NormType == "L2") ? Taquart::ntL2 : Taquart::ntL1;
    int QualityType = 1;
    Taquart::SMTInputData InputData;

    const unsigned int Size = 500;
    int id = 0.0;
    double duration = 0.0, displacement = 0.0;
    double azimuth = 0.0, takeoff = 0.0, velocity = 0.0, distance = 0.0,
        density = 0.0;

    // Load input data
    std::ifstream InputFile;
    InputFile.open(FilenameIn.c_str());
    if (VelocityModel) {
      // Reading formatted input file (velocity model format).
      // TODO: Reading routine.
      double e_northing = 0.0f, e_easting = 0.0f, e_z = 0.0f;
      double s_northing = 0.0f, s_easting = 0.0f, s_z = 0.0f;
      InputFile >> e_northing;
      InputFile >> e_easting;
      InputFile >> e_z;
      InputFile >> density;
      for (unsigned int i = 0; i < N; i++) {
        InputFile >> id;
        InputFile >> s_northing;
        InputFile >> s_easting;
        InputFile >> s_z;
        InputFile >> duration;
        InputFile >> displacement;

        // Calculation of azimuth, takeoff, velocity and distance.
        double depth = fabs(e_z * 0.001);
        double elevation = s_z * 0.001;
        double epicentral_distance = 0.001
            * sqrt(
                pow(s_northing - e_northing, 2.0)
                    + pow(s_easting - e_easting, 2.0));
        double azimuth = atan2(s_easting - e_easting, s_northing - e_northing)
            * 180 / M_PI;
        double takeoff = 0.0;
        double velocity = 0.0;
        double distance = 0.0;
        double null;
        bool null2;
        int null3;
        double aoi;

        for (unsigned int i = Velocity.size() - 1; i >= 0; i--) {
          if (depth >= Top[i]) velocity = Velocity[i];
          break;
        }
        CalcTravelTime1D(elevation, depth, epicentral_distance, Top, Velocity,
            null, takeoff, null2, aoi, null3, distance);

        // Prepare input line structure.
        Taquart::SMTInputLine il;
        il.Name = Taquart::FormatFloat("%02.0f", id);
        il.Id = id;
        il.Component = "ZZ";
        il.MarkerType = "";
        il.Start = 0.0;
        il.End = duration;
        il.Duration = duration;
        il.Displacement = displacement / cos(aoi); // area below the first P wave pulse is divided by angle of incicence. (vertical sensor)
        il.Incidence = aoi;
        il.Azimuth = azimuth;
        il.TakeOff = takeoff;
        il.Distance = distance;
        il.Density = density;
        il.Velocity = velocity;
        il.PickActive = true;
        il.ChannelActive = true;
        InputData.Add(il);
      }
    }
    else {
      // Read formatted input file (standard foci-mt format)
      for (unsigned int i = 0; i < N; i++) {
        InputFile >> id;
        InputFile >> duration; // this is NOT used in current context (incorporated into displacement)!!!
        InputFile >> displacement; // this should hold in fact area below the first P-wave velocity pulse
        InputFile >> azimuth;
        InputFile >> takeoff;
        InputFile >> velocity;
        InputFile >> distance;
        InputFile >> density;

        // Prepare input line structure.
        Taquart::SMTInputLine il;
        il.Name = Taquart::FormatFloat("%02.0f", id); /*!< Station name.*/
        il.Id = id; /*!< Station id number.*/
        il.Component = "ZZ"; //"ZZ";       /*!< Component.*/
        il.MarkerType = ""; //"p*ons/p*max";      /*!< Type of the marker used.*/
        il.Start = 0.0; //tstart;;           /*!< Start time [s].*/
        il.End = duration; //tend;;             /*!< End time [s].*/
        il.Duration = duration; /*!< Duration of first P-wave velocity pulse [s].*/
        il.Displacement = displacement; /*!< Amplitude of first P-wave displacement pulse [m]. */
        il.Incidence = 0; //incidence;       /*!< Angle of incidence [deg] (not used here) */
        il.Azimuth = azimuth; /*!< Azimuth between station and source [deg]. */
        il.TakeOff = takeoff; /*!< Takeoff angle measured from bottom [deg]. */
        il.Distance = distance; /*!< Distance between station and source [m]. */
        il.Density = density; /*!< Density in the source [km/m**3]. */
        il.Velocity = velocity; /*!< Velocity in the source [m/s]. */
        il.PickActive = true;
        il.ChannelActive = true;
        InputData.Add(il);
      }
    }
    InputFile.close();
    bool Result = false;
    InputData.CountRuptureTime(Result);

    // Depending on the method, calculate moment tensor once or N times (Jackknife test)

    // Output structures.

    std::vector<FaultSolutions> FSList;

    // Perform regular SMT inversion with all stations.
    Taquart::FaultSolution fu;
    Taquart::FaultSolution tr;
    Taquart::FaultSolution dc;

    try {
      int ThreadProgress = 0;
      USMTCore(InversionNormType, QualityType, InputData, &ThreadProgress);
    }
    catch (...) {
      std::cout << "Inversion error." << std::endl;
      return 1;
    }

    // Transfer solution.
    TransferSolution(Taquart::stFullSolution, fu);
    TransferSolution(Taquart::stTraceNullSolution, tr);
    TransferSolution(Taquart::stDoubleCoupleSolution, dc);

    FaultSolutions fs;
    fs.Type = 'N';
    fs.Channel = 0;
    fs.FullSolution = fu;
    fs.TraceNullSolution = tr;
    fs.DoubleCoupleSolution = dc;

    FSList.push_back(fs);

    if (NoiseTest) {
      srand((unsigned) time(0));

      const Taquart::SMTInputData fd = InputData;
      for (unsigned int i = 0; i < AmplitudeN; i++) {
        Taquart::SMTInputData td = fd;
        Taquart::SMTInputLine InputLine;

        //std::cout << i << std::endl;
        int sample;
        double u1, u2, z;
        for (unsigned int j = 0; j < td.Count(); j++) {
          td.Get(j, InputLine);
          sample = rand();
          u1 = (sample + 1) / (double(RAND_MAX) + 1);
          sample = rand();
          u2 = (sample + 1) / (double(RAND_MAX) + 1);
          z = sqrt(-2.0 * log(u1)) * cos(2 * M_PI * u2);
          //std::cout << RAND_MAX << " " << sample << " " << u1 << " " << u2<< " " << z << std::endl;
          InputLine.Displacement = InputLine.Displacement
              + z / 3.0 * InputLine.Displacement * AmpFactor;
          td.Set(j, InputLine);
        }

        // Calculate SMT with one station removed.
        try {
          int ThreadProgress = 0;
          USMTCore(InversionNormType, QualityType, td, &ThreadProgress);
        }
        catch (...) {
          std::cout << "Inversion error." << std::endl;
          return 1;
        }

        // Transfer solution.
        TransferSolution(Taquart::stFullSolution, fu);
        TransferSolution(Taquart::stTraceNullSolution, tr);
        TransferSolution(Taquart::stDoubleCoupleSolution, dc);

        FaultSolutions fs;
        fs.Type = 'A';
        fs.Channel = 0;
        fs.FullSolution = fu;
        fs.TraceNullSolution = tr;
        fs.DoubleCoupleSolution = dc;

        FSList.push_back(fs);
      }
    }
    else {
      // Perform additional Jacknife tests.
      if (JacknifeTest) {
        const Taquart::SMTInputData fd = InputData;
        const unsigned int Count = InputData.Count();

        // Remove one channel, calculate the solution,
        for (unsigned int i = 0; i < Count; i++) {
          Taquart::SMTInputData td = fd;
          Taquart::SMTInputLine InputLine;
          td.Get(i, InputLine);
          int channel = InputLine.Id;
          td.Remove(i);

          // Calculate SMT with one station removed.
          try {
            int ThreadProgress = 0;
            USMTCore(InversionNormType, QualityType, td, &ThreadProgress);
          }
          catch (...) {
            std::cout << "Inversion error." << std::endl;
            return 1;
          }

          // Transfer solution.
          TransferSolution(Taquart::stFullSolution, fu);
          TransferSolution(Taquart::stTraceNullSolution, tr);
          TransferSolution(Taquart::stDoubleCoupleSolution, dc);

          FaultSolutions fs;
          fs.Type = 'J';
          fs.Channel = channel;
          fs.FullSolution = fu;
          fs.TraceNullSolution = tr;
          fs.DoubleCoupleSolution = dc;

          FSList.push_back(fs);
        }
      }
    }

    // Produce output file and graphical representation of the moment tensor
    // using Cairo library.

    // Projection type.
    if (Projection.Pos("W")) WulffProjection = true;
    if (Projection.Pos("S")) WulffProjection = false;

    if (Projection.Pos("U")) LowerHemisphere = false;
    if (Projection.Pos("L")) LowerHemisphere = true;

    // Content of ball.
    if (BallContent.Pos("S"))
      DrawStations = true;
    else
      DrawStations = false;

    if (BallContent.Pos("A"))
      DrawAxes = true;
    else
      DrawAxes = false;

    if (BallContent.Pos("C"))
      DrawCross = true;
    else
      DrawCross = false;

    if (BallContent.Pos("D"))
      DrawDC = true;
    else
      DrawDC = false;

    for (unsigned int j = 0; j < FSList.size(); j++) {
      Taquart::FaultSolution Solution = FSList[j].DoubleCoupleSolution;
      char Type = FSList[j].Type;
      int Channel = FSList[j].Channel;

      Taquart::String FSuffix = "dbcp";
      for (int i = 1; i <= SolutionTypes.Length(); i++) {
        switch (SolutionTypes[i]) {
          case 'F':
            Solution = FSList[j].FullSolution;
            FSuffix = "full";
            break;
          case 'T':
            Solution = FSList[j].TraceNullSolution;
            FSuffix = "clvd";
            break;
          case 'D':
            Solution = FSList[j].DoubleCoupleSolution;
            FSuffix = "dbcp";
            break;
        }

        // Output text data if necessary.
        if (DumpOrder.Length()) {
          Taquart::String OutName = FilenameOut + "-" + FSuffix + ".asc";
          ofstream OutFile(OutName.c_str(),
              std::ofstream::out | std::ofstream::app);

          if (JacknifeTest) {
            // Dump additional information when Jacknife test performed.
            OutFile << Type << "\t" << Channel << "\t";
          }

          for (int i = 1; i <= DumpOrder.Length(); i++) {
            // M - moment, D - decomposition, A - axis, F - fault planes,
            // C - moment in CMT convention.

            // Dump moment tensor components.
            if (DumpOrder[i] == 'M') {
              OutFile << Solution.M[1][1] << "\t";
              OutFile << Solution.M[1][2] << "\t";
              OutFile << Solution.M[1][3] << "\t";
              OutFile << Solution.M[2][2] << "\t";
              OutFile << Solution.M[2][3] << "\t";
              OutFile << Solution.M[3][3] << "\t";
            }

            // Dump moment tensor components in CMT convention.
            if (DumpOrder[i] == 'C') {
              OutFile << Solution.M[3][3] << "\t";
              OutFile << Solution.M[1][1] << "\t";
              OutFile << Solution.M[2][2] << "\t";
              OutFile << Solution.M[1][3] << "\t";
              OutFile << -Solution.M[2][3] << "\t";
              OutFile << -Solution.M[1][2] << "\t";
            }

            if (DumpOrder[i] == 'D') {
              OutFile << Solution.EXPL << "\t";
              OutFile << Solution.CLVD << "\t";
              OutFile << Solution.DBCP << "\t";
            }

            if (DumpOrder[i] == 'A') {
              OutFile << Solution.PXTR << "\t";
              OutFile << Solution.PXPL << "\t";
              OutFile << Solution.TXTR << "\t";
              OutFile << Solution.TXPL << "\t";
              OutFile << Solution.BXTR << "\t";
              OutFile << Solution.BXPL << "\t";
            }

            if (DumpOrder[i] == 'F') {
              OutFile << Solution.FIA << "\t";
              OutFile << Solution.DLA << "\t";
              OutFile << Solution.RAKEA << "\t";
              OutFile << Solution.FIB << "\t";
              OutFile << Solution.DLB << "\t";
              OutFile << Solution.RAKEB << "\t";
            }

            if (DumpOrder[i] == 'W') {
              OutFile << Solution.M0 << "\t";
              OutFile << Solution.MT << "\t";
              OutFile << Solution.ERR << "\t";
              OutFile << Solution.MAGN << "\t";
            }

            if (DumpOrder[i] == 'Q') {
              OutFile << Solution.QI << "\t";
            }

            if (DumpOrder[i] == 'T') {
              OutFile << Solution.Type.c_str() << "\t";
            }

            if (DumpOrder[i] == 'U') {
              for (int r = 0; r < Solution.U_n; r++)
                OutFile << Solution.U_th[r] << "\t";
            }

            if (DumpOrder[i] == 'E') {
              OutFile << Solution.UERR << "\t";
            }
          }

          OutFile << "\n";
          OutFile.close();
        }

        // Output picture name

        // Do not dump anything.
        if (OutputFileType.Pos("NONE") && j == 0) continue;

        // Dump to PNG.
        if (OutputFileType.Pos("PNG") && j == 0) {
          try {
            Taquart::String OutName = FilenameOut + "-" + FSuffix + ".png";
            Taquart::TriCairo_Meca Meca(Size, Size, Taquart::ctSurface);
            GenerateBallCairo(Meca, FSList, InputData, FSuffix);
            Meca.Save(OutName);
          }
          catch (...) {
            return 2;
          }
        }

        // Dump to SVG.
        if (OutputFileType.Pos("SVG") && j == 0) {
          try {
            Taquart::String OutName = FilenameOut + "-" + FSuffix + ".svg";
            Taquart::TriCairo_Meca Meca(Size, Size, Taquart::ctSVG, OutName);
            GenerateBallCairo(Meca, FSList, InputData, FSuffix);
          }
          catch (...) {
            return 2;
          }
        }

        // Dump to PS.
        if (OutputFileType.Pos("PS") && j == 0) {
          try {
            Taquart::String OutName = FilenameOut + "-" + FSuffix + ".ps";
            Taquart::TriCairo_Meca Meca(Size, Size, Taquart::ctPS, OutName);
            GenerateBallCairo(Meca, FSList, InputData, FSuffix);
          }
          catch (...) {
            return 2;
          }
        }

        // Dump to PDF.
        if (OutputFileType.Pos("PDF") && j == 0) {
          try {
            Taquart::String OutName = FilenameOut + "-" + FSuffix + ".pdf";
            Taquart::TriCairo_Meca Meca(Size, Size, Taquart::ctPDF, OutName);
            GenerateBallCairo(Meca, FSList, InputData, FSuffix);
          }
          catch (...) {
            return 2;
          }
        }
      }
    } // Loop for all solution types.

    return 0;
  }
  catch (...) {
    return 1; // Some undefined error occurred, error code 1.
  }

}

//-----------------------------------------------------------------------------
void GenerateBallCairo(Taquart::TriCairo_Meca &Meca,
    std::vector<FaultSolutions> &FSList, Taquart::SMTInputData &id,
    Taquart::String Type) {

  Taquart::FaultSolution s;

  if (Type == Taquart::String("dbcp")) {
    s = FSList[0].DoubleCoupleSolution;
  }
  else if (Type == "clvd") {
    s = FSList[0].TraceNullSolution;
  }
  else if (Type == "full") {
    s = FSList[0].FullSolution;
  }

  // Setup solution properties.
  Meca.DrawAxis = DrawAxes;
  Meca.DrawStations = DrawStations;
  Meca.DrawCross = DrawCross;
  Meca.DrawDC = DrawDC;

  // Draw seismic moment tensor solution.
  Meca.Projection = WulffProjection ? Taquart::prWulff : Taquart::prSchmidt;
  Meca.Hemisphere = LowerHemisphere ? Taquart::heLower : Taquart::heUpper;

  double cmt[6];
  cmt[0] = s.M[3][3];
  cmt[1] = s.M[1][1];
  cmt[2] = s.M[2][2];
  cmt[3] = s.M[1][3];
  cmt[4] = s.M[2][3] * -1.0;
  cmt[5] = s.M[1][2] * -1.0;

  Taquart::TriCairo_MomentTensor mt;
  for (int i = 0; i < 6; i++)
    mt.f[i] = cmt[i];

  const double scal =
      sqrt(
          squared(mt.f[0]) + squared(mt.f[1]) + squared(mt.f[2])
              + 2.
                  * (squared(mt.f[3]) + squared(mt.f[4]) + squared(mt.f[5]))) / M_SQRT2;
  for (int i = 0; i < 6; i++)
    mt.f[i] = mt.f[i] / scal;

  Taquart::TriCairo_Axis P, T, N;
  Meca.GMT_momten2axe(mt, &T, &N, &P);
  Meca.Tensor(T, N, P);

  // Draw stations.
  if (DrawStations) {
    for (unsigned int i = 0; i < id.Count(); i++) {
      Taquart::SMTInputLine il;
      id.Get(i, il);

      // Calculate Gamma and Displacement.
      double GA[5];

      double Tko = il.TakeOff;
      if (Tko == 90.0f) Tko = 89.75f;

      GA[3] = cos(Tko * DEG2RAD);
      double help = sqrt(1.0f - GA[3] * GA[3]);
      GA[1] = cos(il.Azimuth * DEG2RAD) * help;
      GA[2] = sin(il.Azimuth * DEG2RAD) * help;
      double U = il.Displacement;
      Taquart::String Name = il.Name;

      double mx, my;
      Meca.Station(GA, U, Name, mx, my);
    }

  }

  // Draw P and T axes' directions.
  if (DrawAxes) {
    Meca.Axis(P, "P");
    Meca.Axis(T, "T");
  }

  if (DrawCross) Meca.CenterCross();

  // Draw double-couple lines.
  if (DrawDC) {
    Meca.BDCColor = Taquart::TCColor(0.0, 0.0, 0.0, 1.0);
    Meca.DoubleCouple(s.FIA, s.DLA);
    Meca.DoubleCouple(s.FIB, s.DLB);
  }

  // If MORE than one solution on the list, plot additional DC lines.
  if (FSList.size() > 1) {
    for (unsigned int i = 1; i < FSList.size(); i++) {
      Meca.BDCColor = Taquart::TCColor(0.5, 0.5, 0.5, 0.7);

      Taquart::FaultSolution * s;

      if (Type == "dbcp") {
        s = &FSList[i].DoubleCoupleSolution;
      }
      if (Type == "clvd") {
        s = &FSList[i].TraceNullSolution;
      }
      if (Type == "full") {
        s = &FSList[i].FullSolution;
      }

      // "Normal fault","Strike fault","Reverse fault"
      if (s->Type == "Normal fault") {
        Meca.BDCColor = Taquart::TCColor(0.0, 0.0, 1.0, 0.7);
      }
      else if (s->Type == "Reverse fault") {
        Meca.BDCColor = Taquart::TCColor(1.0, 0.0, 0.0, 0.7);
      }
      else {
        Meca.BDCColor = Taquart::TCColor(0.0, 1.0, 0.0, 0.7);
      }

      Meca.DoubleCouple(s->FIA, s->DLA);
      Meca.DoubleCouple(s->FIB, s->DLB);
    }
  }

}

//-----------------------------------------------------------------------------
void CalcTravelTime1D(double sta_elev, double depth, double delta,
    std::vector<double> Top, std::vector<double> Velocity, double &traveltime,
    double &takeoff, bool &directphase, double &aoi, int &kk,
    double &ray_dist) {

  if (depth < 0.0) {
    depth = 0.0;
  }

  // The source depth cannot be on layer boundary.
  for (unsigned int i = 0; i < Top.size(); i++) {
    if (fabs(depth - Top[i]) < 0.0001) depth = depth - 0.001;
  }

  // Shift original velocity model according to station elevation.
  std::vector<double> TopAdj;
  TopAdj.clear();
  TopAdj.push_back(0.0);
  for (unsigned int k = 1; k < Top.size(); k++) {
    TopAdj.push_back(Top[k] + sta_elev);
  }

  // Fill in velocity model for travel time calculation.
  double VELOCITY[TT1D_RAYTRACE_MAXLAY];
  double TOP[TT1D_RAYTRACE_MAXLAY];
  VELOCITY[0] = 0.0;
  TOP[0] = 0.0;
  for (unsigned int i = 0; i < TopAdj.size(); i++) {
    VELOCITY[i + 1] = Velocity[i];
    TOP[i + 1] = TopAdj[i];
  }

  // Number of layers.
  const int nl = TopAdj.size();
  ttime(delta, depth + sta_elev, nl, VELOCITY, TOP, traveltime, takeoff,
      directphase, aoi, kk, ray_dist);
}

//-----------------------------------------------------------------------------
void ttime(const double &delta, const double &depth, const int &nl,
    const double v[], const double top[], double &t, double &takeoff,
    bool &directphase, double &aoi, int &kk, double &ray_dist) {
  int jl = 0;
  double tdir = 0.0;
  double thk[TT1D_RAYTRACE_MAXLAY];
  double tkj = 0.0;
  double tref = 0.0;
  double u = 0.0;
  double vsq[TT1D_RAYTRACE_MAXLAY];
  double x = 0.0;
  double xovmax = 0.0;
  double ray_dist_temp = 0.0; // Reset ray distance to 0.0f.

  kk = 0;
  directphase = false;

  vmodel(nl, v, top, depth, vsq, thk, jl, tkj);
  refract(nl, v, vsq, thk, jl, tkj, delta, kk, tref, xovmax, ray_dist_temp);
  t = tref;
  ray_dist = ray_dist_temp;
  if (kk > 0) {
    u = v[jl] / v[kk];
    takeoff = asin(u) * 180.0 / M_PI;
    aoi = asin(v[1] / v[kk]) * 180.0 / M_PI;
  }
  if (delta <= xovmax) {
    double ray_dist_temp2 = 0.0;
    direct1(nl, v, vsq, thk, jl, tkj, delta, depth, tdir, u, x, ray_dist_temp2);
    if (tref > tdir) {
      t = tdir;
      ray_dist = ray_dist_temp2;
      takeoff = 180.0 - asin(u) * 180.0 / M_PI;
      aoi = asin(sin(takeoff * M_PI / 180.0) * v[1] / v[jl]) * 180.0 / M_PI;
      directphase = true;
    }
  }
}

//-----------------------------------------------------------------------------
void vmodel(const int& nl, const double v[], const double top[],
    const double &depth, double vsq[], double thk[], int &jl, double &tkj) {
  int i = 0;
  for (i = 1; i <= nl; i++)
    vsq[i] = v[i] * v[i];
  jl = nl;
  for (i = 1; i <= nl; i++) {
    if (depth <= top[i]) {
      jl = i - 1;
      break;
    }
  }
  for (i = 1; i <= nl - 1; i++) {
    double a = top[i + 1] - top[i];
    thk[i] = a;
  }
  tkj = depth - top[jl];
}

//-----------------------------------------------------------------------------
void direct1(const int &nl, const double v[], const double vsq[],
    const double thk[], const int& jl, const double& tkj, const double& delta,
    const double& depth, double& tdir, double& u, double& x,
    double &ray_direct) {
  double r = 0.0, tklmax = 0.0, usq = 0.0;
  int lmax = 0, j1 = 0, l = 0;
  double vlmax = 0, del = 0.0, xtest = 0.0;
  double ua = 0.0, ub = 0.0, uasq = 0.0, ubsq = 0.0, xa = 0.0, xb = 0.0, dela =
      0.0, delb = 0.0, ubdiv = 0.0;
  ray_direct = 0.0;
  if (jl == 1) {
    r = hypot(depth, delta);
    tdir = r / v[1];
    u = delta / r;
    x = delta;
    ray_direct = r;
    return;
  }
  lmax = jl;
  tklmax = tkj;
  vlmax = v[jl];
  j1 = jl - 1;
  for (l = 1; l <= j1; l++) {
    if (v[l] > vlmax) {
      lmax = l;
      tklmax = thk[l];
      vlmax = v[l];
    }
  }
  if (tklmax <= 0.05) tklmax = 0.05;

  ua = (v[jl] / vlmax) * delta / sqrt(delta * delta + depth * depth);
  ub = (v[jl] / vlmax) * delta / sqrt(delta * delta + tklmax * tklmax);
  uasq = ua * ua;
  ubsq = ub * ub;
  if (ubsq >= 1.0f) ubsq = 0.99999;
  if (uasq >= 1.0f) uasq = 0.99999;
  xa = tkj * ua / sqrt(1.0 - uasq);
  if (lmax == jl) {
    xb = delta;
  }
  else {
    xb = tkj * ub / sqrt(1.0 - ubsq);
  }
  dela = xa;
  delb = xb;
  for (l = 1; l <= j1; l++) {
    dela = dela + thk[l] * ua / sqrt(vsq[jl] / vsq[l] - uasq);
    ubdiv = sqrt(vsq[jl] / vsq[l] - ubsq);
    if (ubdiv <= 1.0e-20) {
      ubdiv = 1.0e-20;
    }
    delb = delb + thk[l] * ub / sqrt(vsq[jl] / vsq[l] - ubsq);
  }
  for (int kount = 1; kount <= 25; kount++) {
    if (((delb - dela) < 0.02)) {
      x = 0.5 * (xa + xb);
      u = x / sqrt(x * x + tkj * tkj);
      usq = u * u;
      goto L23193;
    }
    x = xa + (delta - dela) * (xb - xa) / (delb - dela);
    u = x / sqrt(x * x + tkj * tkj);
    usq = u * u;
    del = x;
    for (int l = 1; l <= j1; l++) {
      del = del + thk[l] * u / sqrt(vsq[jl] / vsq[l] - usq);
    }
    xtest = del - delta;
    if (fabs(xtest) < 0.02) goto L23193;
    if (xtest < 0.0) {
      xa = x;
      dela = del;
    }
    else {
      xb = x;
      delb = del;
    }
  } // 23192
  L23193: tdir = sqrt(x * x + tkj * tkj) / v[jl];
  ray_direct = sqrt(x * x + tkj * tkj);

  for (int l = 1; l <= j1; l++) {
    tdir = tdir + thk[l] * v[jl] / (vsq[l] * sqrt(vsq[jl] / vsq[l] - usq));
    ray_direct = ray_direct
        + thk[l] * v[jl] / (v[l] * sqrt(vsq[jl] / vsq[l] - usq));
  }

  // PM&GK: It is not clear what's the purpose of the following lines!
  tdir = tdir - (u / v[jl]) * (del - delta);
  ray_direct = ray_direct - u * (del - delta);
}

//-----------------------------------------------------------------------------
void refract(const int nl, const double v[], const double vsq[],
    const double thk[], const int jl, const double tkj, const double delta,
    int &kk, double &tref, double &xovmax, double &ray_refract) {

  // tkj - depth of event in certain layer.
  // delta - horizontal distance between event and receiver
  double tid[TT1D_RAYTRACE_MAXLAY];
  double did[TT1D_RAYTRACE_MAXLAY]; // Terms in critical distance independent of tkj
  double rid[TT1D_RAYTRACE_MAXLAY];
  double tinj[TT1D_RAYTRACE_MAXLAY]; // Travel time intercept
  double didj[TT1D_RAYTRACE_MAXLAY]; // Critical distance
  double rinj[TT1D_RAYTRACE_MAXLAY];
  double tr[TT1D_RAYTRACE_MAXLAY]; // Travel time for refraction in layer X
  double rr[TT1D_RAYTRACE_MAXLAY];
  int j1 = 0;
  int jx = 0;
  int l = 0;
  int lx = 0;
  int m = 0;
  int m1 = 0;
  double sqt = 0.0;
  double tim = 0.0;

  tiddid(jl, nl, v, vsq, thk, tid, did, rid);
  tref = TT1D_MAXT;
  ray_refract = TT1D_MAXT;
  j1 = jl + 1;
  for (m = j1; m <= nl; m++) {
    if (tid[m] == TT1D_MAXT) {
      tr[m] = TT1D_MAXT;
      rr[m] = TT1D_MAXT;
    }
    else {
      sqt = sqrt(vsq[m] - vsq[jl]);
      tinj[m] = tid[m] - tkj * sqt / (v[m] * v[jl]);
      didj[m] = did[m] - tkj * v[jl] / sqt;
      rinj[m] = rid[m] - tkj * v[m] / sqt;
      tr[m] = tinj[m] + delta / v[m];
      rr[m] = rinj[m] + delta - didj[m];
      if (didj[m] > delta) {
        tr[m] = TT1D_MAXT;
        rr[m] = TT1D_MAXT;
      }
    }
    if (tr[m] < tref) {
      tref = tr[m];
      ray_refract = rr[m];
      kk = m;
    } //23157 continue
  } // 23151

  if (tref == TT1D_MAXT) {
    xovmax = TT1D_MAXT;
    kk = 0;
    return;
  } //23159 continue
  m = jl + 1;
  while (1) {
    if (!(tid[m] == TT1D_MAXT)) break;
    m = m + 1;
  }
  lx = m;

  if (jl == 1) {
    xovmax = tinj[lx] * v[lx] * v[1] / (v[lx] - v[1]);
    return;
  }
  m = jl;
  l23165: tid[m] = 0.0f;
  m1 = m - 1;
  for (l = 1; l <= m1; l++) {
    if (vsq[m] <= vsq[l]) {
      tid[m] = TT1D_MAXT;
    }
    else {
      sqt = sqrt(vsq[m] - vsq[l]);
      tim = thk[l] * sqt / (v[l] * v[m]);
      tid[m] = tid[m] + tim;
    }
  }
  m = m - 1;

  if (!(tid[m + 1] < TT1D_MAXT || m == 1)) goto l23165;

  if (tid[m + 1] < TT1D_MAXT) {
    jx = m + 1;
    xovmax = (tinj[lx] - tid[jx]) * v[lx] * v[jx] / (v[lx] - v[jx]);
  }
  else {
    xovmax = tinj[lx] * v[lx] * v[1] / (v[lx] - v[1]);
  }
}

//-----------------------------------------------------------------------------
void tiddid(const int &jl, const int &nl, const double v[], const double vsq[],
    const double thk[], double tid[], double did[], double rid[]) {
  double did1 = 0.0, did2 = 0.0, dimm = 0.0, rid1 = 0.0, rid2 = 0.0;
  int j1 = 0, l = 0, m = 0, m1 = 0;
  double sqt = 0.0, tid1 = 0.0, tid2 = 0.0, tim = 0.0, rim = 0.0;
  j1 = jl + 1;
  for (m = j1; m <= nl; m++) {
    tid[m] = 0.0;
    did[m] = 0.0;
    tid1 = 0.0;
    tid2 = 0.0;
    did1 = 0.0;
    did2 = 0.0;
    rid1 = 0.0;
    rid2 = 0.0;
    m1 = m - 1;
    for (l = 1; l <= m1; l++) {
      if ((vsq[m] <= vsq[l])) {
        tid[m] = 100000.0;
        did[m] = 100000.0;
        rid[m] = 100000.0;
        continue;
      } //23178 continue
      sqt = sqrt(vsq[m] - vsq[l]);
      tim = thk[l] * sqt / (v[l] * v[m]);
      dimm = thk[l] * v[l] / sqt;
      rim = thk[l] * v[m] / sqt;
      if ((l < jl)) {
        tid1 = tid1 + tim;
        did1 = did1 + dimm;
        rid1 = rid1 + rim;
      }
      else {
        tid2 = tid2 + tim;
        did2 = did2 + dimm;
        rid2 = rid2 + rim;
      }
    } //23176 continue

    if ((tid[m] != 100000.0)) {
      tid[m] = tid1 + 2 * tid2;
      did[m] = did1 + 2 * did2;
      rid[m] = rid1 + 2 * rid2;
    }
  } //23174 continue
}
